<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rocket Dodge</title>
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            background-color: #09daff;
        }
        canvas {
            background-color: #09daff;
            cursor: none;
        }
        .overlay {
            position: fixed;
            display: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 2;
        }
        .overlay.tutorial {
            cursor: pointer;
            display: block;
        }
        .overlay-text {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 45px;
            color: white;
            transform: translate(-50%,-50%);
            -ms-transform: translate(-50%,-50%);
        }
    </style>
</head>

<body onload = "myGameArea.initialize()">

    <div id="tutorial" class="overlay tutorial" onclick="myGameArea.start()">
        <div id="tutorialText" class="overlay-text">Avoid red dots, make them collide with each other to gain points. Pause with esc, steer with arrows or wasd.<br><br>Click anywhere or press spacebar to start</div>
    </div>

    <div id="pause" class="overlay">
        <div id="pauseText" class="overlay-text">Press ESC to resume</div>
    </div>

    <div id="gameover" class="overlay">
        <div id="gameOverText" class="overlay-text"></div>
    </div>

    <script>
        // variables below can be changed arbitrarily
        const fps = 60; // frame number per second
        const speed = 10; // how many pixels the player moves in one frame
        const missileColor = "red"; // color of the components chasing the player
        const playerColor = "black"; // color of the player
        const playerHeadColor = "grey"; // color of the player's head
        const scoreTextColor = "black"; // color of the score text color
        const missileSize = 20; // the length of one edge of the square missile in pixels
        const difficulty = 1; // changes missile speed increse rate
        const rotateSpeed = 6; // player's rotation speed
        const initialMissileInterval = 150; // how often the missiles appear initially in miliseconds
        const initialMissileSpeed = 4; // how many pixels missiles move in one frame initially

        let myGamePiece; // rocket that the player controls
        let missiles; // array which contains hostile missiles
        let missileInterval;
        let missileSpeed;
        let keyBoardButtons = {
            left: [65, 37],
            up: [87, 38],
            right: [68, 39],
            down: [83, 40],
            esc: 27,
            space: 32,
        };
        let rightPressed, leftPressed, upPressed, downPressed;
        let score = 0;

        //contains canvas and canvas related methods
        var myGameArea = {
            canvas: document.createElement("canvas"), // create the canvas
            //initialize the canvas
            initialize: function () {
                this.started = false; // true if game has started
                this.ongoing = false; // true if game has started and hasn't ended yet (pausing does not count)
                this.paused = false; // true if game is paused

                //proccess pressed buttons
                window.addEventListener('keydown', keyDownHandler, false);
                window.addEventListener('keyup', keyUpHandler, false);

                this.canvas.width = window.innerWidth; // set canvas width to window width
                this.canvas.height = window.innerHeight; // set canvas height to window height

                this.context = this.canvas.getContext("2d"); // context field provides access to various useful canvas methods
                document.body.appendChild(this.canvas); // insert canvas into html
                
                myGamePiece = new player(10, 60, playerColor, playerHeadColor,225, 225); // initialize player
                myGamePiece.update();
                printScore(score);
            },
            // start game by starting interval
            start: function () {
                if (!this.ongoing) {
                    this.frameNo = 0; // this value increases with every frame from now on
                    this.started = true;
                    this.ongoing = true;
                    rightPressed, leftPressed, upPressed, downPressed = false;
                    missiles = [];
                    missileInterval = initialMissileInterval;
                    missileSpeed = initialMissileSpeed;
                    document.getElementById("tutorial").style.display = "none";
                    this.interval = new IntervalTimer(updateGameArea, 1000 / fps);
                    this.scoreCounter = new IntervalTimer(() => {score++}, 1000); // score increases by one every second
                }
            },
            // pauses the game
            pause: function () {
                if (!this.paused && this.ongoing) {
                    this.paused = true;
                    document.getElementById("pause").style.display = "block";
                    this.scoreCounter.pause();
                    this.interval.pause();
                }
            },
            // resumes the game
            resume: function () {
                if (this.paused && this.ongoing) {
                    this.paused = false;
                    document.getElementById("pause").style.display = "none";
                    this.scoreCounter.resume();
                    this.interval.resume();
                }
            },
            // stops updating the game area
            gameover: function () {
                this.ongoing = false;
                this.interval.pause();
                this.scoreCounter.pause();
                document.getElementById("gameover").children[0].innerHTML = "GAME OVER<br>Your Score: " + score;
                document.getElementById("gameover").style.display = "block";
            },
            // restarts the game
            restart: function () {
                if (!this.ongoing) {
                    document.getElementById("gameover").style.display = "none";
                    document.getElementById("tutorial").style.display = "block";
                    score = 0;
                    this.initialize();
                }
            },
            // clears canvas
            clear: function () {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            },
        }

        function player(width, height, color, headColor, x, y) {
            this.width = width;
            this.height = height;
            this.speed = 0;
            this.angle = 0; // angle change in one frame in radians
            this.moveAngle = 0; // angle change in one frame in degrees
            this.currentAngle = 0; // where the player is facing right now
            this.x = x;
            this.y = y;
            // update component position
            this.newPos = function () {
                this.currentAngle += this.moveAngle; // add angle change to current angle
                // keep current angle between 0 and 360
                if (this.currentAngle < 0) {
                    this.currentAngle += 360;
                } else if (this.currentAngle >= 360) {
                    this.currentAngle -= 360;
                }
                this.angle += this.moveAngle * Math.PI / 180; // translate angle into radians
                // change player coordinates according to the angle
                // y is being subtracted while x is being added because y coordinate gets greater downwards in html canvas
                this.x += this.speed * Math.sin(this.angle);
                this.y -= this.speed * Math.cos(this.angle);
            }
            // updates newly positioned component on the canvas
            // probably the most complicated method of the game
            this.update = function () {
                let ctx = myGameArea.context;
                ctx.save(); // save current canvas
                ctx.translate(this.x, this.y); // canvas origin is now x, y
                ctx.rotate(this.angle); // rotate the canvas so that rectangle rotates
                ctx.fillStyle = color; // set fill color of players main part
                ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height); // paint the rectangle
                ctx.fillStyle = headColor;
                ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height / 5);
                ctx.restore(); //return previous state and attributes of canvas
            }
            // do not let player leave the screen
            this.inBounds = function () {
                if (myGamePiece.x < myGamePiece.height / 2) {
                    myGamePiece.speed = 0;
                    myGamePiece.x += 1;
                }
                if (myGamePiece.x > myGameArea.canvas.width - myGamePiece.height / 2) {
                    myGamePiece.speed = 0;
                    myGamePiece.x -= 1;
                }
                if (myGamePiece.y < myGamePiece.height / 2) {
                    myGamePiece.speed = 0;
                    myGamePiece.y += 1;
                }
                if (myGamePiece.y > myGameArea.canvas.height - myGamePiece.height / 2) {
                    myGamePiece.speed = 0;
                    myGamePiece.y -= 1;
                }
            }
            // check if this object crashes with other object
            this.crashWith = function (otherobj) {
                var myleft = this.x;
                var myright = this.x + (this.width / 10);
                var mytop = this.y;
                var mybottom = this.y + (this.height / 10);
                var otherleft = otherobj.x;
                var otherright = otherobj.x + (otherobj.width);
                var othertop = otherobj.y;
                var otherbottom = otherobj.y + (otherobj.height);
                var crash = true;
                if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {
                    crash = false;
                }
                return crash;
            }
        }

        function missile(width, height, color, x, y, speed) {
            this.width = width;
            this.height = height;
            this.speed = speed;
            this.angle = 0;
            this.moveAngle = 0;
            this.currentAngle = 0;
            this.x = x;
            this.y = y;
            // updates component position
            this.newPos = function () {
                this.dx = myGamePiece.x - this.x; // distance to the player in x dimension
                this.dy = myGamePiece.y - this.y; // distance to the player in y dimension
                this.distance = Math.sqrt((this.dx * this.dx) + (this.dy * this.dy)); // distance to the player
                // coordinate assigments below keep the missile on the path between itself and the player
                this.x += this.speed * (this.dx / this.distance);
                this.y += this.speed * (this.dy / this.distance);
            }
            // updates newly positioned component on the canvas
            this.update = function () {
                let ctx = myGameArea.context;
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            // this method checks if this object crashes with other object
            this.crashWith = function (otherobj) {
                var myleft = this.x;
                var myright = this.x + (this.width);
                var mytop = this.y;
                var mybottom = this.y + (this.height);
                var otherleft = otherobj.x;
                var otherright = otherobj.x + (otherobj.width);
                var othertop = otherobj.y;
                var otherbottom = otherobj.y + (otherobj.height);
                var crash = true;
                if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {
                    crash = false;
                }
                return crash;
            }
        }

        // this method updates the game area, is called every frame
        function updateGameArea() {
            myGameArea.frameNo++;
            // check if player collides with one of missiles
            for (i = 0; i < missiles.length; i++) {
                if (myGamePiece.crashWith(missiles[i])) {
                    myGameArea.gameover();
                    return;
                }
                for (j = 0; j < missiles.length; j++) {
                    if (i != j && missiles[i].crashWith(missiles[j])) {
                        missiles.splice(i, 1);
                        missiles.splice(j - 1, 1);
                        score += 10;
                    }
                }
            }
            // clear last frame
            myGameArea.clear();
            // resize the canvas if window size has changed
            if ((window.innerWidth != myGameArea.canvas.width) || (window.innerHeight != myGameArea.canvas.height)) {
                myGameArea.canvas.width = window.innerWidth;
                myGameArea.canvas.height = window.innerHeight;
            }
            // create new hostile missile every missileInterval frames
            if ((myGameArea.frameNo / missileInterval) % 1 == 0) {
                let x;
                let y;
                if (Math.random() < 0.5) {
                    x = Math.random() * (-100);
                } else {
                    x = myGameArea.canvas.width + Math.random() * 100;
                }
                if (Math.random() < 0.5) {
                    y = Math.random() * (-100);
                } else {
                    y = myGameArea.canvas.height + Math.random() * 100;
                }
                missiles.push(new missile(missileSize, missileSize, missileColor, x, y, missileSpeed));
                missileSpeed += (difficulty / missileSpeed);
                missileInterval -= Math.round(missileInterval / 50);
            }

            myGamePiece.moveAngle = 0;
            myGamePiece.speed = 0;
            if (leftPressed && rightPressed) {
                myGamePiece.moveAngle = 0;
            } else if (leftPressed) {
                myGamePiece.moveAngle = -rotateSpeed;
            } else if (rightPressed) {
                myGamePiece.moveAngle = rotateSpeed;
            }
            if (upPressed) {
                myGamePiece.speed = speed;
            }
            // if (downPressed) {
            //     myGamePiece.speed = -speed;
            // }
            for (i = 0; i < missiles.length; i++) {
                missiles[i].newPos();
                missiles[i].update();
            }
            myGamePiece.inBounds();
            myGamePiece.newPos();
            myGamePiece.update();
            printScore(score);
        }

        // prints the score on canvas
        function printScore (score) {
            let ctx = myGameArea.context;
            ctx.font = "30px Arial";
            ctx.fillStyle = scoreTextColor;
            ctx.fillText("Score: " + score, 10, 50);
        }

        // this object creates pauseable intervals
        function IntervalTimer(callback, interval) {
            var timerId, startTime, remaining = 0;
            var state = 0; //  0 = idle, 1 = running, 2 = paused, 3= resumed

            this.pause = function () {
                if (state != 1) return;

                remaining = interval - (new Date() - startTime);
                window.clearInterval(timerId);
                state = 2;
            };

            this.resume = function () {
                if (state != 2) return;

                state = 3;
                window.setTimeout(this.timeoutCallback, remaining);
            };

            this.timeoutCallback = function () {
                if (state != 3) return;

                callback();

                startTime = new Date();
                timerId = window.setInterval(callback, interval);
                state = 1;
            };

            startTime = new Date();
            timerId = window.setInterval(callback, interval);
            state = 1;
        }

        function keyDownHandler(event) {
            if (keyBoardButtons.right.includes(event.keyCode)) {
                event.preventDefault();
                rightPressed = true;
            }
            if (keyBoardButtons.left.includes(event.keyCode)) {
                event.preventDefault();
                leftPressed = true;
            }
            if (keyBoardButtons.down.includes(event.keyCode)) {
                event.preventDefault();
                downPressed = true;
            }
            if (keyBoardButtons.up.includes(event.keyCode)) {
                event.preventDefault();
                upPressed = true;
            }
            if (event.keyCode == keyBoardButtons.esc) {
                event.preventDefault();
                if (myGameArea.paused) {
                    myGameArea.resume();
                }
                else {
                    myGameArea.pause();
                }
            }
            if (event.keyCode == keyBoardButtons.space) {
                event.preventDefault();
                if (!myGameArea.started) {
                    myGameArea.start();
                }
                else {
                    myGameArea.restart();
                }
            }
        }

        function keyUpHandler(event) {
            if (keyBoardButtons.right.includes(event.keyCode)) {
                rightPressed = false;
            }
            if (keyBoardButtons.left.includes(event.keyCode)) {
                leftPressed = false;
            }
            if (keyBoardButtons.down.includes(event.keyCode)) {
                downPressed = false;
            }
            if (keyBoardButtons.up.includes(event.keyCode)) {
                upPressed = false;
            }
        }
    </script>

</body>

</html>
