<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
        }

        canvas {
            border: 1px solid #d3d3d3;
            background-color: #09daff;
        }
    </style>
</head>

<body onload="startGame()">

    <script>
        const fps = 60; // frame number per second
        const speed = 10; // how many pixels the player moves in one frame

        let myGamePiece; // rocket that the player controls
        let missiles = []; // array which contains hostile missiles
        let keyBoardButtons = { left: [65, 37], up: [87, 38], right: [68, 39], down: [83, 40] };
        let rightPressed, leftPressed, upPressed, downPressed = false;

        //main function, starts the game
        function startGame() {
            myGamePiece = new component(10, 60, "black", 225, 225); // initialize player
            myGameArea.start(); //start the game
        }

        //contains canvas and canvas related methods
        var myGameArea = {
            canvas: document.createElement("canvas"), // create the canvas
            //initialize the canvas
            start: function () {
                this.canvas.width = window.innerWidth; // set canvas width to window width
                this.canvas.height = window.innerHeight; // set canvas height to window height
                this.context = this.canvas.getContext("2d"); // context field provides access to various useful canvas methods
                document.body.appendChild(this.canvas); // insert canvas into html
                this.frameNo = 0; // this value increases with every frame from now on
                this.interval = setInterval(updateGameArea, 1000 / fps); // update game area every 1000/fps miliseconds
                //proccess pressed buttons
                window.addEventListener('keydown', keyDownHandler, false);
                window.addEventListener('keyup', keyUpHandler, false);
            },
            // stops update game area interval
            stop: function () {
                clearInterval(this.interval);
            },
            // clears canvas
            clear: function () {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }

        function component(width, height, color, x, y) {
            this.width = width;
            this.height = height;
            this.speed = 0;
            this.angle = 0;
            this.moveAngle = 0;
            this.x = x;
            this.y = y;
            this.update = function () {
                ctx = myGameArea.context;
                ctx.font = "30px Arial";
                ctx.fillText("x: " + this.x + "\ny: " + this.y, 10, 50);
                ctx.save(); // save current canvas
                ctx.translate(this.x, this.y); // canvas origin is now x, y
                ctx.rotate(this.angle); // rotate the canvas so that rectangle rotates
                ctx.fillStyle = color; // set fill color
                ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height); // paint the rectangle
                ctx.restore(); //return previous state and attributes
            }
            // update component position
            this.newPos = function () {
                this.angle += this.moveAngle * Math.PI / 180;
                this.x += this.speed * Math.sin(this.angle);
                this.y -= this.speed * Math.cos(this.angle);
            }
            // check if this object crashes with other object
            this.crashWith = function (otherobj) {
                var myleft = this.x;
                var myright = this.x + (this.width);
                var mytop = this.y;
                var mybottom = this.y + (this.height);
                var otherleft = otherobj.x;
                var otherright = otherobj.x + (otherobj.width);
                var othertop = otherobj.y;
                var otherbottom = otherobj.y + (otherobj.height);
                var crash = true;
                if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {
                    crash = false;
                }
                return crash;
            }
        }

        function missile (width, height, color, x, y, speed) {
            this.width = width;
            this.height = height;
            this.speed = speed;
            this.angle = 0;
            this.moveAngle = 0;
            this.x = x;
            this.y = y;
            this.update = function () {
                ctx = myGameArea.context;
                ctx.save(); // save current canvas
                ctx.translate(this.x, this.y); // canvas origin is now x, y
                ctx.rotate(this.angle); // rotate the canvas so that rectangle rotates
                ctx.fillStyle = color; // set fill color
                ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height); // paint the rectangle
                ctx.restore(); //return previous state and attributes
            }
            // updates component position
            this.newPos = function () {
                this.angle += this.moveAngle * Math.PI / 180;
                this.x += this.speed * Math.sin(this.angle);
                this.y -= this.speed * Math.cos(this.angle);
            }
            // this method checks if this object crashes with other object
            this.crashWith = function (otherobj) {
                var myleft = this.x;
                var myright = this.x + (this.width);
                var mytop = this.y;
                var mybottom = this.y + (this.height);
                var otherleft = otherobj.x;
                var otherright = otherobj.x + (otherobj.width);
                var othertop = otherobj.y;
                var otherbottom = otherobj.y + (otherobj.height);
                var crash = true;
                if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {
                    crash = false;
                }
                return crash;
            }
        }

        function updateGameArea() {
            // check if player collides with one of missiles
            for (i = 0; i < missiles.length; i++) {
                if (myGamePiece.crashWith(missiles[i])) {
                    myGameArea.stop();
                    return;
                }
                for (j = 0; j < missiles.length; j++) {
                    if (i != j && missiles[i].crashWith(missiles[j])) {
                        missiles.splice(i, 1);
                        missiles.splice(j, 1);
                    }
                }
            }
            myGameArea.clear();
            myGameArea.frameNo++;
            // create new hostile missile every 150 frames
            if (everyinterval(150)) {
                let x;
                let y;
                if (Math.random() < 0.5) {
                    x = Math.random() * (-100);
                } else {
                    x = myGameArea.canvas.width + Math.random() * 100;
                }
                if (Math.random() < 0.5) {
                    y = Math.random() * (-100);
                } else {
                    y = myGameArea.canvas.height + Math.random() * 100;
                }
                missiles.push(new missile(10, 60, "red", 255, 255, Math.random() * 10 + 10));
            }

            myGamePiece.moveAngle = 0;
            myGamePiece.speed = 0;
            if (leftPressed && rightPressed) {
                myGamePiece.moveAngle = 0;
            }
            else if (leftPressed) {
                myGamePiece.moveAngle = -speed;
            }
            else if (rightPressed) {
                myGamePiece.moveAngle = speed;
            }
            if (upPressed) {
                myGamePiece.speed = speed;
            }
            // if (downPressed) {
            //     myGamePiece.speed = -speed;
            // }
            if (myGamePiece.x < myGamePiece.height / 2) {
                myGamePiece.speed = 0;
                myGamePiece.x += 1;
            }
            if (myGamePiece.x > myGameArea.canvas.width - myGamePiece.height / 2) {
                myGamePiece.speed = 0;
                myGamePiece.x -= 1;
            }
            if (myGamePiece.y < myGamePiece.height / 2) {
                myGamePiece.speed = 0;
                myGamePiece.y += 1;
            }
            if (myGamePiece.y > myGameArea.canvas.height - myGamePiece.height / 2) {
                myGamePiece.speed = 0;
                myGamePiece.y -= 1;
            }
            myGamePiece.newPos();
            myGamePiece.update();
            for (i = 0; i < missiles.length; i++) {
                missiles[i].moveAngle = Math.atan( (myGamePiece.x - missiles[i].x) / (myGamePiece.y - missiles[i].y));
                missiles[i].newPos();
                missiles[i].update();
            }
        }

        function everyinterval(n) {
            if ((myGameArea.frameNo / n) % 1 == 0) {
                return true;
            }
            return false;
        }

        function keyDownHandler(event) {
            if(keyBoardButtons.right.includes(event.keyCode)) {
                rightPressed = true;
            }
            if(keyBoardButtons.left.includes(event.keyCode)) {
                leftPressed = true;
            }
            if(keyBoardButtons.down.includes(event.keyCode)) {
                downPressed = true;
            }
            if(keyBoardButtons.up.includes(event.keyCode)) {
                upPressed = true;
            }
        }
        function keyUpHandler (event) {
            if(keyBoardButtons.right.includes(event.keyCode)) {
                rightPressed = false;
            }
            if(keyBoardButtons.left.includes(event.keyCode)) {
                leftPressed = false;
            }
            if(keyBoardButtons.down.includes(event.keyCode)) {
                downPressed = false;
            }
            if(keyBoardButtons.up.includes(event.keyCode)) {
                upPressed = false;
            }
        }
    </script>

</body>

</html>